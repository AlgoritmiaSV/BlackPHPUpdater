#!/bin/bash
# Para cada nombre de proyecto (Carpeta = Clave) se define una base de datos (Valor)
declare -A databases
databases[blackphp]=blackphp
databases[negkit]=negkit
databases[sicoimWebApp]=sicoim
databases[acrossdesk]=acrossdesk
databases[mimakit]=mimakit

# Posibles tipos de columna en la base de datos (Se deben registrar las faltantes)
declare -A types
types[int]=int
types[smallint]=int
types[tinyint]=int
types[char]=string
types[varchar]=string
types[text]=string
types[smalltext]=string
types[tinytext]=string
types[date]=string
types[datetime]=string
types[float]=float
types[decimal]=float

# Si se ejecuta sin parámetros, se hace un volcado de todas las bases de datos definidas en el arreglo; sino, se realiza sólo de las que han sido especificadas.
if [ "$#" = "0" ]; then
	$0 ${!databases[@]}
	exit 1
fi

for folder in "$@"; do
	echo "------------ ORM for project $folder"
	if [ -v databases[$folder] ]; then
		tables=`mysql --skip-column-names -u root -pldi14517 -e "show tables from ${databases[$folder]}"`
		table_position=0
		table_name=""
		for table in $tables; do
			file=/store/blackphp/orm/$folder/$table"_model.php"
			echo "Model for table $table"
			echo "<?php" > $file
			echo "/**" >> $file
			echo " * Model for $table" >> $file
			echo " * " >> $file
			echo " * Generated by BlackPHP" >> $file
			echo " */" >> $file
			echo "" >> $file
			echo "class "$table"_model" >> $file
			echo "{" >> $file
			echo -e "\tuse ORM;" >> $file
			echo "" >> $file

			#Propiedades generales
			echo -e "\t/** @var string \$_table_name Nombre de la tabla */" >> $file
			echo -e "\tprivate \$_table_name;" >> $file
			echo "" >> $file
			echo -e "\t/** @var string \$_primary_key Llave primaria */" >> $file
			echo -e "\tprivate \$_primary_key;" >> $file
			echo "" >> $file
			echo -e "\t/** @var bool \$_timestamps La tabla usa marcas de tiempo para la inserción y edición de datos */" >> $file
			echo -e "\tprivate \$_timestamps;" >> $file
			echo "" >> $file
			echo -e "\t/** @var bool \$_soft_delete La tabla soporta borrado suave */" >> $file
			echo -e "\tprivate \$_soft_delete;" >> $file
			echo "" >> $file

			# Consultando columnas y creando propiedades
			# Esta consulta obtiene resultados en tres columnas
			columns=`mysql --skip-column-names -u root -pldi14517 -e "SELECT COLUMN_NAME, DATA_TYPE, IF(COLUMN_COMMENT = '', '-', REPLACE(COLUMN_COMMENT, ' ', '_')) AS COMMENT FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '${databases[$folder]}' AND TABLE_NAME = '$table'"`
			column_position=0
			column_name=""
			column_type=""
			timestamps=false
			ts_fields=0
			soft_delete=false
			for column_data in $columns; do
				if [ $column_position -eq 0 ]; then
					column_name=$column_data
					if [ "$column_name" = "creation_user" -o "$column_name" = "creation_time" -o "$column_name" = "edition_user" -o "$column_name" = "edition_time" ]; then
						((ts_fields=ts_fields+1))
					fi
					if [ "$column_name" = "status" ]; then
						soft_delete=true
					fi
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 1 ]; then
					column_type=$column_data
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 2 ]; then
					column_comment=$column_data
					column_position=0
					echo -ne "\t/** @var ${types[$column_type]} \$$column_name" >> $file
					echo " $column_comment */" | sed 's/_/\ /g' >> $file
					echo -e "\tprivate \$$column_name;" >> $file
					echo "" >> $file
				fi
			done

			# Si $ts_fields es 4, es porque se encontraron los campos necesatios para el registro
			# de timestamps
			if [ $ts_fields -eq 4 ]; then
				timestamps=true
			fi

			# Constructor de la clase (Inicializa las variables generales)
			# Todavía se está considerando incluir estas variables generales en una clase base.
			echo -e "\t/**" >> $file
			echo -e "\t * Constructor de la clase" >> $file
			echo -e "\t * " >> $file
			echo -e "\t * Inicializa las propiedades generales de la tabla" >> $file
			echo -e "\t */" >> $file
			echo -e "\tpublic function __construct()" >> $file
			echo -e "\t{" >> $file
			
			# Establece el nombre de la tabla
			echo -e "\t\t\$this->_table_name = \"$table\";" >> $file

			# Establece el nombre de la llave foránea. (Funciona sólo para llaves primarias de un
			# solo campo).
			echo -e "\t\t\$this->_primary_key = \"`mysql --skip-column-names -u root -pldi14517 -e "select column_name from information_schema.KEY_COLUMN_USAGE where CONSTRAINT_NAME = 'PRIMARY' AND TABLE_SCHEMA='${databases[$folder]}' AND TABLE_NAME='$table' LIMIT 1"`\";" >> $file

			# Determina si la tabla soporta timestamps (creation_user, creation_time, edition_user y edition_time)
			echo -e "\t\t\$this->_timestamps = $timestamps;" >> $file

			# Determina si la tabla soporta borrado suave (Se necesita un campo de estado $status)
			echo -e "\t\t\$this->_soft_delete = $soft_delete;" >> $file
			echo -e "\t}" >> $file

			# Métodos públicos para el acceso a las propiedades.
			# En los setters está pensado realizar validaciones según el tipo de datos,
			# pero esto aún no está incluído en esta edición.
			column_name=""
			column_type=""
			for column_data in $columns; do
				if [ $column_position -eq 0 ]; then
					column_name=$column_data
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 1 ]; then
					column_type=$column_data
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 2 ]; then
					echo "" >> $file
					echo -e "\tpublic function get${column_name^}()" >> $file
					echo -e "\t{" >> $file
					echo -e "\t\treturn \$this->$column_name;" >> $file
					echo -e "\t}" >> $file
					echo -e "" >> $file
					echo -e "\tpublic function set${column_name^}(\$value)" >> $file
					echo -e "\t{" >> $file
					echo -e "\t\t\$this->$column_name = (${types[$column_type]})\$value;" >> $file
					echo -e "\t}" >> $file
					column_position=0
				fi
			done

			# Llaves foráneas
			keys=`mysql --skip-column-names -u root -pldi14517 -e "SELECT TABLE_NAME, COLUMN_NAME,CONSTRAINT_NAME, REFERENCED_COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE REFERENCED_TABLE_SCHEMA = '${databases[$folder]}' AND REFERENCED_TABLE_NAME = '$table' GROUP BY TABLE_NAME"`
			column_position=0
			table_name=""
			column_name=""
			constraint_name=""
			referenced_column_name=""
			for key_data in $keys; do
				if [ $column_position -eq 0 ]; then
					table_name=$key_data
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 1 ]; then
					column_name=$key_data
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 2 ]; then
					constraint_name=$key_data
					((column_position=column_position+1))
					continue
				fi
				if [ $column_position -eq 3 ]; then
					referenced_column_name=$key_data
					echo "" >> $file
					echo -e "\tpublic function $table_name()" >> $file
					echo -e "\t{" >> $file
					echo -e "\t\t$table_name::flush();" >> $file
					echo -e "\t\treturn $table_name::where(\"$column_name\", \$this->$referenced_column_name);" >> $file
					echo -e "\t}" >> $file
					column_position=0
				fi
			done

			#Fin
			echo "}" >> $file
			echo "?>" >> $file
		done

		#Sincronizar
		rsync -cr --delete --info=NAME1 /store/blackphp/orm/$folder/ /store/Clouds/Mega/www/$folder/models/orm/
	else
		echo "Project $1 not exists"
	fi
done
